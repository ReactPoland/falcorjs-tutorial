### Full-stack login and registration for our publishing app

<!-- TODO: DESCRIBE DIFFERENCE BETWEEN: The oAuth2, OpenID Connect and JSON Web Tokens (JWT) (if not enough page's count) -->


JWT is a security tokens format which is relatively new, but works very well. It's an open standard (RFC 7519) that improves oAuth2 and OpenID Connect in problem of passing claims between parties in web application environment.

More in practise the flow is as follwoing:
1) the server assigns an encoded JSON object
2) after client's knows it, then it sends that encoded token with every request to the server
3) based on that token, the server knows who is sending a request

It's worth to visit the http://jwt.io/ website and play with it because you can play with it even before you will start working with them:

![screenshot http://jwt.io/](http://test.przeorski.pl/book/101_jwt_io.png)

After successful login, the JWT's solution provides an object to our front-end application that tell's us about current's user authorization:

```
{"iss":"PublishginAppIssuer","name":"John Doe","admin":true}
```

The iss is an issuer property - in our case it will be our publishing app's backend application. Name of logged user is obvious - John Doe has logged in successfully. The admin property just is saying that an identified user (logged into our backend's app with correct login and password) is an admin ("admin": true flag). You will learn how to use it in that chapter.

Beside what has been said in the above's example, the JWT's response contains also information about subject/claims, signed SHA256's generated token and an expiration date. The important rule here is that you must be sure about the issuer of your token because then you need to trust to the content's provided alongside in the response. It may sounds complicated, but ***it is very simple*** in real life applications.

The important thing is that you ***need*** to keep protected the token generated by JWT - this security's topic will be elaborated later.


The flow is as following:
1) Our client's publishing app request a token from our express' server
2) The publishing backed app's issues a token to the front-end redux's app
3) And after that, each time we fetch data from backend then we check if a user has access to a requested resources on the backend - ***the resource consumes the token***.

In our case the resource is a falcor-router's routes which has close relationship with the backend, but this may work as well in more distributed platforms.

Remember that the JWT tokens are similar to private's keys - you must keep them secure!


### Structure of JWT token

1) The header has information that are required on the backend for recognizing what cryptographic operation to do based on that information (metadata, what algorithms & keys are used)

```
{
	"typ": "JWT",
	"alg": "HS256"
}
```

In general, that part is done 100% out of the box for us, so we don't have to care too much about headers while implementing it.


2) The second part are claims provided in the JSON format, as for example:

a) Issuer - so we know who has issued the token
b) Audience - so we know that this token has to be consumed by our application
c) Issue's date - when the token has been created
d) Expiration's date - when the token is expiring so we have to generate a new one
e) Subject - so an app can know which part of the app can use the token (useful in bigger application)

Besides the claims provided above, we can create custom one that are specific definied by the app's creator.

```
{
"iss": "http://theIssuerAddress",
"exp": "1450819372",
"aud": "http://myAppAddress",
"sub": "publishingApp",
"scope": ["read"]
}
```


TODO - review above.



PLAN PISANIA:
0) dodanie kolekcji users w bazie mongodb
1) stworzenie route'a do logowania usera
2) dodanie formularza na front'cie


### New MongoDB's users collection

We need create a users collection in our database. The users will have privilages to:
1) Add new articles in our publishing application
2) Edit existing articles in our publishing application
3) Delete articles in our publishing application.


First step is that we need to create a collection.

You can do it from GUI in Robomongo (introduced at the beginning of the book), but we here will use the command line.

First of all we need to create a file called initPubUsers.js:
```
$ [[you are in the root directory of your project]]
$ touch initPubUsers.js
```

then add the content following content to the initPubUsers.js:
```
[
  {
    "username" : "admin",
    "password" : "c5a0df4e293953d6048e78bd9849ec0ddce811f0b29f72564714e474615a7852",
    "firstName" : "Kamil",
    "lastName" : "Przeorski",
    "email" : "kamil@mobilewebpro.pl",
    "role" : "admin",
    "verified" : false,
    "imageUrl" : "http://lorempixel.com/100/100/people/"
  }
]
```

##### Explanation:
The SHA256 string c5a0df4e293953d6048e78bd9849ec0ddce811f0b29f72564714e474615a7852 is a equilavent of a password 123456 with a salt's string equalt to "pubApp".

If you want to generate this salted password hash yourself, then go to:
http://www.xorbin.com/tools/sha256-hash-calculator

and type ***123456pubApp*** on their website so you will get as following:
![sha256 salted password online](http://test.przeorski.pl/book/102_salted_password_sha256.png)


These steps are required only on the beginning, later we need to program a registration form that is salting the password for our own.


##### Importing the initPubUsers.js file into MongoDB
After we have the correct content in our initPubUsers.js then we can run a command line as following in order to import that new pubUsers collection to our database:
```
mongoimport --db local --collection pubUsers --jsonArray initPubUsers.js --host=127.0.0.1
```

and you will get the same terminal's output as we were importing the article in the first chapter similar to this:
```
2009-04-03T11:36:00.566+0200  connected to: 127.0.0.1
2009-04-03T11:36:00.569+0200  imported 1 document
```

#### Working on the login's falcor-route

Now we need to start working with the falcor-router in order to create a new endpoint that will use the jwt library to provide a unique tokens for the client-side app.

The first thing that we need to do is to provide a "secret" on the backend.

Let's create that secret's config file:
```
$ cd server
$ touch configSecret.js
```

Now we need to put a content of this secret:
```
export default {
  'secret': process.env.JWT_SECRET || 'devSecretGoesHere'
}
```
In future we will use enviroment variables on the production server, so this notation ***process.env.JWT_SECRET  || 'devSecretGoesHere'*** means that the enviroment variable of JWT_SECRET doesn't exsit then please use deafult secret's string ('devSecretGoesHere'). At this point we don't need any development enviroment variables.


#### Creating a falcor-router's login (backend)

In order to make our codebase more organized, instead of adding one more route to our ***server/routes.js*** file, we will make a new file called ***routesSession.js*** and in that file we will keep all endpoints related to the current logged user's session:

Make sure you are in the server dir:
```
$ cd server
```

First open the server.js file on order to add one line of code that will allow to post usernames and passwords to the backend, so add this:
```
app.use(bodyParser.urlencoded({extended: false}));
```
... this has to be added under ***app.use(bodyParser.json({extended: false}));*** so you will end up with server.js code that begins as following:
```
import http from 'http';
import express from 'express';
import cors from 'cors';
import bodyParser from 'body-parser';
import mongoose from 'mongoose';
import falcor from 'falcor';
import falcorExpress from 'falcor-express';
import Router from 'falcor-router';
import routes from './routes.js';

var app = express();
app.server = http.createServer(app);

// CORS - 3rd party middleware
app.use(cors());

// This is required by falcor-express middleware to work correctly with falcor-browser
app.use(bodyParser.json({extended: false}));
app.use(bodyParser.urlencoded({extended: false}));
```
... the last line is a new line that has to be added in order to make it works. Then create a new file in the same directory with:
```
$ touch routesSession.js
```

And put this initial content into the ***routesSession.js*** file:

```
export default [
  { 
    route: ['login'] ,
    call: (callPath, args) => 
      {
        let { username, password } = args[0];

        let userStatementQuery = {
          $and: [
              { 'username': username },
              { 'password': password }
          ]
        }
      }
  }
];
```

#### Explanation how works the call routes:
Above we have created an initial call login route in the ***routesSession.js*** file. You can find that instead of using 'get' method, we are going to use a 'call' (***call: async (callPath, args) => ***). That is equivalent of POST for old RESTful approach. 

The difference between call and get method in falcor's routes is that we can provide arguments with ***args***. That allows us to get from the client-side the username and the password. 

The plan is that after we receive credentials with this:
```
let { username, password } = args[0];
```

then we will check them against our database with one user admin. A user will need to know that the real plaintext password is ***123456*** in order to get a correct login jwt token.

We also have prepared in this step a ***userStatementQuery*** - this will be used later when querying a database:
```
let userStatementQuery = {
  $and: [
      { 'username': username },
      { 'password': password }
  ]
}
```

#### Separating the DB configs - configMongoose.js

We need to separate DB configs from routes.js:
```
$ touch configMongoose.js
```

and it's new content:
```
import mongoose from 'mongoose';

const conf = {
  hostname: process.env.MONGO_HOSTNAME || 'localhost',
  port: process.env.MONGO_PORT || 27017,
  env: process.env.MONGO_ENV || 'local',
};

mongoose.connect(`mongodb://${conf.hostname}:${conf.port}/${conf.env}`);

var articleSchema = {
  articleTitle:String,
  articleContent:String
}

var Article = mongoose.model('Article', articleSchema, 'articles');

export default {
  Article
}
```

#### Explanation:
Above we have introduced new env variables as following: MONGO_HOSTNAME, MONGO_PORT, MONGO_ENV. We will use them when preparing a production enviroment. 

The ***`mongodb://${conf.hostname}:${conf.port}/${conf.env}`*** is using templating feature available since EcmaScript6.

Rest of the configMongoose.js config shall be known for you as we introduced it in the chapter 1.

#### Improving the routes.js file
After we have two new files: configMongoose.js and routesSession.js then we have to improve our ***server/routes.js*** file in order to make everything cooperate together.


First step, delete from routes.js the following code:
```
import mongoose from 'mongoose';

mongoose.connect('mongodb://localhost/local');

var articleSchema = {
  articleTitle:String,
  articleContent:String
}

var Article = mongoose.model('Article', articleSchema, 'articles');
```

and replace it with new:
```
import configMongoose from './configMongoose.js';
let Article = configMongoose.Article;
import sessionRoutes from './routesSession';
```

also we need to spread the sessionRoutes into our current PublishingAppRoutes as following:
```
let PublishingAppRoutes = [
    ...sessionRoutes,
  {
  route: 'articles.length',
```
At the beginning of PublishingAppRoutes you need to spread ***...sessionRoutes,*** routes, so the login route will be available to use accross the Falcor's routes.

#### Explanation
We got rid off old code that was helping us to run the first mongoose query that were fetching the articles, we moved everyting to ***configMongoose*** so then we can use it in different files around our project. We have also imported the ***sessionRoutes*** and later spreaded them with the ***...*** spread operation into the array called ***PublishingAppRoutes***.

#### Double-check if app works, before implementing JWT
At this point, when doing ***npm start*** the app shall be working and showing the list of articles:
```
Our publishing app

Lorem ipsum - article one

Here goes the content of the article

Lorem ipsum - article two

Sky is the limit, the content goes here.
```

when running with ***npm start*** you shall get the following information that everything works correctly:
```
Hash: eeeb09711c820a7978d5
Version: webpack 1.12.14
Time: 2609ms
 Asset    Size  Chunks             Chunk Names
app.js  1.9 MB       0  [emitted]  main
   [0] multi main 40 bytes {0} [built]
    + 634 hidden modules
Started on port 3000
```

#### Creating a Mongoose users' model

In the file ***configMongoose.js*** we need to create and export a User model. Please add following code to that file:
```
var userSchema = {
  "username" : String,
  "password" : String,
  "firstName" : String,
  "lastName" : String,
  "email" : String,
  "role" : String,
  "verified" : Boolean,
  "imageUrl" : String
}

var User = mongoose.model('User', userSchema, 'pubUsers');


export default {
  Article,
  User
}
```
#### Explanation
The ***userSchema*** describes our user's json model, next the ***User*** is our mongoose's model that is pointing to the 'pubUsers' collection in our MongoDB. At the end, we are exporting the ***User*** model by adding it to the ***export default***'s object. 


#### Implementing JWT in the routesSession.js file

First step is to export our User's model into the routesSession's scope by adding at the top of that file an import statement:
```
import configMongoose from './configMongoose';
let User = configMongoose.User;
````

Installing the jsonwebtoken & crypto (for SHA256):
```
$ npm i --save jsonwebtoken crypto
```

After you have installed jsonwebtoken, the we need to import it to the ***routesSession.js***:
```
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import jwtSecret from './configSecret';
```

After you have imported everything in the routesSession, then let's
continue on working with the ***route: ['login']***.

Below you need to improve the userStatementQuery, so it will have the saltedPassword instead of plain text:
```
let saltedPassword = password+"pubApp"; // pubApp is our salt string
let saltedPassHash = crypto.createHash('sha256').update(saltedPassword).digest('hex');
let userStatementQuery = {
  $and: [
      { 'username': username },
      { 'password': saltedPassHash }
  ]
}
``` 
... so instead of plain text, then we will query a salted SHA256 password.

... under this ***userStatementQuery*** please return a Promise, with following details:
```
        return User.find(userStatementQuery, function(err, user) {
          if (err) throw err;
        }).then((result) => {
          if(result.length) {
            return null; // SUCCESSFUL LOGIN mocked now (will implement next)
          } else {
            // INVALID LOGIN
            return [
              {
                path: ['login', 'token'], 
                value: "INVALID"
              },
              {
                path: ['login', 'error'], 
                value: "NO USER FOUND, incorrect login information" 
              }
            ];
          }
          return result;
        });
```

#### Explanation
The ***User.find*** is a Promise that comes from the Mongoose's user's model (that we have created in configMongoose.js) - this is a standard method. Then as a first argument we provide ***userStatementQuery*** which is that filter's object with username and password in it (****{ username, password } = args[0];***). 

Next we provide a function that is a callback, when the query is done (***function(err, user) {***). We count amount of results with ***if(result.length) {***. 

In case if result.length === 0 then we have mocked return statement, then we are getting the else code running with following return:
```
            return [
              {
                path: ['login', 'token'], 
                value: "INVALID"
              },
              {
                path: ['login', 'error'], 
                value: "NO USER FOUND, incorrect login information" 
              }
            ];
```

As you will learn later, we will ask for that token's path on the front-end (later in this chapter) ***['login', 'token']***. In this case we haven't found the correct username and the password provided so we return ***"INVALID"*** string, instead of a JWT token. The path ***['login', 'error']*** is describing the error's type in more details so that message can be shown to a user that has provided invalid login's credentials.


#### Successful login on falcor-route
We need to improve successful login path. We have a case for handling an invalid login, we need to make a case that will handle a successful login, so please replace this code:
```
return null; // SUCCESSFUL LOGIN mocked now (will implement next)
```

with this code that is returning successful login's details:
```
let role = result[0].role;
let userDetailsToHash = username+role;
let token = jwt.sign(userDetailsToHash, jwtSecret.secret);
return [
  {
    path: ['login', 'token'],
    value: token
  },
  {
    path: ['login', 'username'],
    value: username
  },
  {
    path: ['login', 'role'],
    value: role
  },
  {
    path: ['login', 'error'],
    value: false
  }
];
```

#### Explanation:
As you can see, the only thing that we fetch from DB right now is the role value === ***result[0].role***. We need add this to hash, because we don't want our app to be vulnerable so a normal user can get an admin role with some hacking. The value of the ***token*** is calculated based on ***userDetailsToHash = username+role*** - that's enough for now.

After we are fine here the only thing that needs to be done on the backend is returning the paths with values:
1) The login token with: ['login', 'token']
2) The username with ['login', 'username']
3) The logged user's role with: ['login', 'role']
4) ... and an information that there were no errors' at all with: ['login', 'error']

The next step is to use this route on the Front-end.

Please run the app and then if everything is working for you, and after it works for you then let's to start the front-end codings' fun right now!



### Front-end side and Falcor

Let's create a new route for login in our redux application. In order to do that, we need to introduce the ***react-router***:
```
$ npm i --save react-router@1.0.0 redux-simple-router@0.0.10 redux-thunk@1.0.0
```

PLEASE NOTE: it's important to use correct NPM's versions - otherwise things may broke! [[[NOTE to our editor: in June we shall revise the versions and improve the codebase to make it more actual as things evolve very quickly in the ecosystem!]]]

After we have installed them, we need to add routes in the src:
```
$ cd src
$ mkdir routes
$ touch index.js
```

then make the content of this index.js file as following:
```
import React                        from 'react';
import { Route, IndexRoute }        from 'react-router';

/* wrappers */
import CoreLayout                   from '../layouts/CoreLayout';

/* home view */
import PublishingApp                    from '../layouts/PublishingApp';

/* auth views */
import LoginView                    from '../views/LoginView';

export default (
  <Route component={CoreLayout} path='/'>
    <IndexRoute component={PublishingApp} name='home' />
    <Route component={LoginView} path='login' name='login' />
  </Route>
);
```

At this points we are missing two components for our app called CoreLayout & LoginView (we will implement them in a minute).

#### CoreLayout's component
The CoreLayout is the a for our whole application.

Create it by doing as following:
```
cd ../layouts/
touch CoreLayout.js
```

... and then populate it with the following content:
```
import React from 'react';
import { Link } from 'react-router';

class CoreLayout extends React.Component {
  static propTypes = {
    children : React.PropTypes.element
  }

  constructor(props) {
    super(props);

  }

  render () {
    return (
      <div>
        <span>Links: <Link to='/login'>Login</Link> | <Link to='/'>Home Page</Link></span>
          <br/>
          {this.props.children}
      </div>
    );
  }
}

export default CoreLayout;
```
As you probably know, the all content of a current route will go into the ***{this.props.children}***'s target (that is basic's React.JS concept you must to know beforehand). We also created two links to our routes as a header.


#### LoginView's component
For the time being, we will create a mocked LoginView as you can find below with the "FORM GOES HERE"'s placeholder:
```
"use strict";

import React from 'react';
import Falcor from 'falcor';
import falcorModel from '../falcorModel.js';
import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';

const mapStateToProps = (state) => ({
  ...state
});

const mapDispatchToProps = (dispatch) => ({

});

class LoginView extends React.Component {
  constructor(props) {
    super(props);
  }

  render () {
    return (
      <div>
          <h1>Login view</h1>
          FORM GOES HERE
      </div>
    );
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(LoginView);
```

We are done with all missing pieces for the ***routes/index.js***, but there some other outstanding stuff to do before our app with the routing will be working.

#### A ROOT's container for our app
Because our is getting more complicated, we need to create a container that it will live in, in order to do that let's do as following the in ***src*** location:
```
$ pwd 
$ [[[you shall be at the src folder]]]
$ mkdir containers
$ cd container
$ touch Root.js
```

The Root.js is going to be our main root file - the content of this file is as following:
```
import React                    from 'react';
import { Provider }             from 'react-redux';
import { Router }               from 'react-router';
import routes                   from '../routes';
import createHashHistory        from 'history/lib/createHashHistory';

let noQueryKeyHistory = createHashHistory({
  queryKey: false
});

export default class Root extends React.Component {
  static propTypes = {
    history : React.PropTypes.object.isRequired,
    store   : React.PropTypes.object.isRequired
  }

  render () {
    return (
      <Provider store={this.props.store}>
        <div>
          <Router history={noQueryKeyHistory}>
            {routes}
          </Router>
        </div>
      </Provider>
    );
  }
}
```
For now it's only simple container, but later we will implement into it more futures for debugging, hot reloading reasons etc. The ***noQueryKeyHistory*** is saying to the Router, that we don't want to have any random strings in our url so our routes will be looking nicer (not a big deal, you can change the false flag to true, to see what I am talking about).


#### Remaining configuration for: configureStore & rootReducer

Let's create a rootReducer first. Why we need it? Because in bigger applications you always endup with many different reducers, for example in our app we will have reducers as:
1) Article's reducer: which is keeps stuff related to articles (RETURN_ALL_ARTICLES etc.)
2) Session's reducer: which will be keeping related to our users' sessions (LOGIN, REGISTER etc.)
3) Editor's reducer: which will be related to editor's actions (EDIT_ARTICLE, DELETE_ARTICLE, ADD_NEW_ARTICLE etc.)
4) Routing's reducer: that will manage state of our routes (out of the box, because it is managed by redux-simple-router's external lib)

Let's create an index.js file in our reducers directory:
```
$ pwd 
$ [[[you shall be at the src folder]]]
$ cd reducers
$ touch index.js
```

... and the content for the index.js is as following:
```
import { combineReducers }    from 'redux';
import { routeReducer }       from 'redux-simple-router';

import article  from './article';

export default combineReducers({
  routing: routeReducer,
  article
});
```
The new thing is that we are introducing a combineReducers' function from Redux. This is exactly, what I've written before: we will have more than one reducers - in our case we have also introducing the routeReducer from a redux-simple-router's library.


Next step is to create the configureStore that will be managing our stores also in order to implement a server rendering later in this book.

```
$ pwd 
$ [[[you shall be at the src folder]]]
$ mkdir store
$ cd store
$ touch configureStore.js
```

... and the content for the configureStore.js:
```
import rootReducer          from '../reducers';
import thunk                from 'redux-thunk';
import {
  applyMiddleware,
  compose,
  createStore
} from 'redux';

export default function configureStore (initialState, debug = false) {
  let createStoreWithMiddleware;

  const middleware = applyMiddleware(thunk);

  createStoreWithMiddleware = compose(middleware);

  const store = createStoreWithMiddleware(createStore)(
    rootReducer, initialState
  );
  return store;
}
```
In the above's code we are importing the rootReducer that we've created recently. We also import the redux-thunk's lib which is very useful for server side rendering (described later in the book). 

At the end, we export a store which is composed of many different's reducers (currently routing and article's reducer that you can find in ***reducer/index.js***) and is able to handle the server rendering initial's state.


#### Tweaks in layouts/PublishingApp.js

We have out-of-date code in PublishingApp. Why outdated? Because we have introduced rootReducer and combineReducers so if you will check your code in render of PublishingApp here:
```
    let articlesJSX = [];
    for(let articleKey in this.props) {
      let articleDetails = this.props[articleKey];
      let currentArticleJSX = (
        <div key={articleKey}>
          <h2>{articleDetails.articleTitle}</h2>
          <h3>{articleDetails.articleContent}</h3>
        </div>);
      articlesJSX.push(currentArticleJSX);
    }
```

... then it won't work, because you are you need to change it to this:
```
    let articlesJSX = [];
    for(let articleKey in this.props.article) {
      let articleDetails = this.props.article[articleKey];
      let currentArticleJSX = (
        <div key={articleKey}>
          <h2>{articleDetails.articleTitle}</h2>
          <h3>{articleDetails.articleContent}</h3>
        </div>);
      articlesJSX.push(currentArticleJSX);
    }
```

Do you see the difference? The old ***for(let articleKey in this.props)*** has changed into ***for(let articleKey in this.props.article)*** and ***this.props[articleKey]*** has changed to ***this.props.article[articleKey]***. Why? I will recall again: now every new reducer will be available in our app via it's name created in ***routes/index.js***. We have named our reducer article, so we now had to add this into ***this.props.article*** to make this stuff works together.

#### Last changes in src/app.js before running the app

Last thing is to improve the src/app.js so it will use the Root's container. We need to change the old:

```
// old codebase, to improve:
import React from 'react'
import { render } from 'react-dom'
import { Provider } from 'react-redux'
import { createStore } from 'redux'
import article from './reducers/article'
import PublishingApp from './layouts/PublishingApp'

let store = createStore(article)

render(
    <Provider store={store}>
        <PublishingApp store={store} />
    </Provider>,
    document.getElementById('publishingAppRoot')
);
```

... the above's code we need to change to the below's one:

```
import React                  from 'react';
import ReactDOM               from 'react-dom';
import createBrowserHistory   from 'history/lib/createBrowserHistory';
import { syncReduxAndRouter } from 'redux-simple-router';
import Root                   from './containers/Root';
import configureStore         from './store/configureStore';

const target  = document.getElementById('publishingAppRoot');
const history = createBrowserHistory();

export const store = configureStore(window.__INITIAL_STATE__);

syncReduxAndRouter(history, store);

const node = (
  <Root
    history={history}
    store={store}
  />
);

ReactDOM.render(node, target);
```

We start using the Root's instead of the Provider directly, and we need to send the store and history's props below to the Root component. The ***export const store = configureStore(window.__INITIAL_STATE__)***'s part is here for the server's side rendering which we will add in one of the next chapters. We also use the history's library to manage browser's history with the JavaScript.


#### Screenshots of our running app:

Currently when you do ***npm start*** then you will see as following two routes:


#### Home Page:

![screenshot home view](http://test.przeorski.pl/book/103_homeview.png)


#### Login's View:

![screenshot login view](http://test.przeorski.pl/book/104_loginview.png)


### Working on the login form that will call the backend in order to authenticate

OK, so we have done a lot of preparation in terms of having an extensible project structure (routes, rootReducer, configStores etc).

In order to make our app nicer from a user perspective we will start using Material Design CSS. For making our work easier with forms, we will start using a ***formsy-react***'s library. Let's install them:
```
$ npm i --save material-ui@0.15.0-alpha.1 formsy-react@0.17.0
```

At the time writing this, the version ***0.15.0-alpha.2*** if Material UI is the newest one - I put this version above because the ecosystem is changing so quickly that it's better to mark the used version in here so you won't have any suprises when following the instructions in that book.

The ***formsy-react***'s library will help you to write more efficient forms code, so it will be a please as you can learn in a while.

#### Working on LoginForm and DefaultInput components

After we are done with installing our new dependencies then let's create a folder that will keep files related to dumb components (the components that don't have access to any stores etc. they communicate with the other parts of our application with help of callbacks - you will learn more about it later).

```
$ pwd 
$ [[[you shall be at the src folder]]]
$ mkdir components
$ cd components
$ touch DefaultInput.js
```

and then please make a content of this file as following:
```
import React from 'react';
import {TextField} from 'material-ui';
import {HOC} from 'formsy-react';

class DefaultInput extends React.Component {
  constructor(props) {
    super(props);
    this.changeValue = this.changeValue.bind(this);
    this.state = { currentText: null }
  }

  changeValue(e) {
    this.setState({currentText: e.target.value})
    this.props.setValue(e.target.value);
    this.props.onChange(e);
  }

  render() {
    return (<div>
        <TextField 
          ref={this.props.name}
          floatingLabelText={this.props.title}
          name={this.props.name}
          onChange={this.changeValue}
          required={this.props.required}
          type={this.props.type}
          value={this.state.currentText ? this.state.currentText : this.props.value}
          defaultValue={this.props.defaultValue} />
        {this.props.children}
      </div>);
  }
};
export default HOC(DefaultInput);
```

#### Explanation
The ***{HOC}*** from ***formsy-react*** is another way of decorating the component (aka mixin in React's EcmaScript5) with ***export default HOC(DefaultInput)*** - you can find more information about this here: https://github.com/christianalfoni/formsy-react/blob/master/API.md#formsyhoc

We are using here also the ***TextField*** from material-ui - then it takes different properties - short explanation:
1) ref: we want a ref for each input with it's name (username and email)
2) floatingLabelText: this is a nice looking floating text (aka label)
3) onChange: this tells the function's name that has to be called when someone is typing into the TextField
4) required: helps us to manage required inputs in our form
5) value: is of course current value of our TextField
6) defaultValue: is a value that is initial. Very important to remember is that it's called just once when a component is calling a constructor of the component

Also the only state of this component is ***this.state.currentText*** in order to keep a current's text value of the component so it can know about yourself in order to behave correctly.


#### LoginForm and making it works with LoginView

Next step is to create LoginForm, that will use this DefaultInput's component with following commands:

```
$ pwd 
$ [[[you shall be at the components folder]]]
$ touch LoginForm.js
```

and then the content of our ***src/components/LoginForm.js*** file is as following:
```
import React from 'react';
import Formsy from 'formsy-react';
import { RaisedButton, Paper } from 'material-ui';
import DefaultInput from './DefaultInput';

export class LoginForm extends React.Component {
  constructor() {
    super();
  }

  render() {
    return (
      <Formsy.Form onSubmit={this.props.onSubmit}>
        <Paper zDepth={1} style={{padding: 32}}>
          <h3>Log in</h3>
          <DefaultInput onChange={(event) => {}} name='username' title='Username (default in the book is admin)' required />
          <DefaultInput onChange={(event) => {}} type='password' name='password' title='Password (default in the book is 123456)' required />
          <div style={{marginTop: 24}}>
            <RaisedButton
              secondary={true}
              type="submit"
              style={{margin: '0 auto', display: 'block', width: 150}}
              label={'Log in'} />
          </div>
        </Paper>
      </Formsy.Form>
    );
  }
}
```
Above we have our LoginForm's component that is using the DefaultInput's component. It's simple React.js' form that after submit is calling the ***this.props.onSubmit*** - this onSubmit function will be definied in ***src/views/LoginView.js***'s smart component in a moment. I won't talk too much about attached styles on that component because it's up to you how you will style it - you will see a screenshot of aplied styles of our app in a moment.

IMPORTANT: if you followed exactly the book's instruction while working on the user's collection, then the default password and username shall be the same as in the title's of DefaultInput's component ("default in the book is admin" and "default in the book is 123456"). 

#### Clarification on the hash and passwords in our pubUsers' collection

We have created hashed password in our pubUsers' collection:
```
[
  {
    "username" : "admin",
    "password" : "c5a0df4e293953d6048e78bd9849ec0ddce811f0b29f72564714e474615a7852",
    "firstName" : "Kamil",
    "lastName" : "Przeorski",
    "email" : "kamil@mobilewebpro.pl",
    "role" : "admin",
    "verified" : false,
    "imageUrl" : "http://lorempixel.com/100/100/people/"
  }
]
```

You need to understand how this works, it secures the plain password in order to keep it safe from hackers (in case when a hacker will compromise the database).



#### Improving the src/views/LoginView.js

The last part at our development at this stage before running our application is to improve the LoginView's component.

In src/views/LoginView.js change as following:

1) Import our new LoginForm component:
```
import { LoginForm } from '../components/LoginForm.js';
```

2) then improve our constructor from:
```
  // this is old constructor
  constructor(props) {
    super(props);
  }
```

to new one:
```
  constructor(props) {
    super(props);
    this.state = {
      error: null
    };
    this.login = this.login.bind(this);
  }
```

3) then after you are done with imports and constructors, then you need a new function called login:
```
  async login(credentials) {
    console.info("credentials", credentials);

    let loginResult = await falcorModel
      .call(
            ['login'],
            [credentials]
          ).
      then((result) => {
        return loginResult;
      });

    let tokenRes = await falcorModel.getValue('login.token');
    console.info("tokenRes", tokenRes);
    return;
  }
````
At this point, the login function only prints our new JWT token to the console - it's enough for now, later we will build more on top of it.

4) last step here is to improve our render function from:
```
  render () {
    return (
      <div>
          <h1>Login view</h1>
          FORM GOES HERE
      </div>
    );
  }
```

to the new one, that is following:
```
  render () {
    return (
      <div>
          <h1>Login view</h1>
          <div style={{maxWidth: 450, margin: '0 auto'}}>
            <LoginForm
              onSubmit={this.login} />
          </div>
      </div>
    );
  }
```

Great! Now we are done! Below you can find what you shall see after running ***npm start*** and running it in your browser:

![screenshot after filling and submiting login form](http://test.przeorski.pl/book/105_screenshot_after_submit_login_form.png)

As you can see in the browser's console - we can see the submited credential's object (***credentials Object {username: "admin", password: "123456"}***) and also a token that has been fetched from the backend (***tokenRes eyJhbGciOiJIUzI1NiJ9.YWRtaW5hZG1pbg.NKmrphxbqNcL_jFLBdTWGM6Y_Q78xks5E2TxBZRyjDA***) - all that tells us that we are on a good track in order to implement the login's mechanism in our publishing application.

IMPORTANT: if you get an INVALID's login error then please make sure that you have used the 123456 password while creating the hash. Otherwise, please type in your custom password that is valid in your case.


### Making DashboardView's component

At this point we have a login feature that is not finished, but before continuing the work on it, let's create a simple ***src/views/DashboardView.js*** component that will be shown after a successful login:

```
$ pwd 
$ [[[you shall be at the views folder]]]
$ touch DashboardView.js
```

with a simple content as following:
```
"use strict";

import React from 'react';
import Falcor from 'falcor';
import falcorModel from '../falcorModel.js';
import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';
import { LoginForm } from '../components/LoginForm.js';

const mapStateToProps = (state) => ({
  ...state
});

const mapDispatchToProps = (dispatch) => ({

});

class DashboardView extends React.Component {
  constructor(props) {
    super(props);
  }

  render () {
    return (
      <div>
          <h1>Dashboard - loggedin!</h1>
      </div>
    );
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(DashboardView);
```

This is simple component, that is static at this point - later we will build more features into it.

The last thing regarding the dashboard's that we need to create is a new route in the ***src/routes/index.js***'s file:
```
import DashboardView from '../views/DashboardView';

export default (
  <Route component={CoreLayout} path='/'>
    <IndexRoute component={PublishingApp} name='home' />
    <Route component={LoginView} path='login' name='login' />
    <Route component={DashboardView} path='dashboard' name='dashboard' />
  </Route>
);
```

We have added two things:
1) ***import DashboardView from '../views/DashboardView';***
2) ***<Route component={DashboardView} path='dashboard' name='dashboard' />***

Nothing fancy - we have created a dashboard route in the react-router's config.

#### Finishing the login's mechanism

The last improvements for login at this point of our publishing app is remaining at the ***src/views/LoginView.js***'s location:

1) First of all, let's add handling an invalid logins:
```
    console.info("tokenRes", tokenRes);

    if(tokenRes === "INVALID") {
      // login failed, get error msg
      let errorRes = await falcorModel.getValue('login.error');
      this.setState({error: errorRes});
      return;
    }

    return;
```

we have added this ***if(tokenRes === "INVALID")*** in order to update the  error state with ***this.setState({error: errorRes})***.

2) next step is to add into the render function a Snackbar that will show to the user a type of the error - in top of the LoginView's component add this import:

```
import { Snackbar } from 'material-ui';
```

Also change this piece of code:
```
this.state = {
      error: null
    };
    this.login = this.login.bind(this);
```

That it has new handler and new initial state:
```

this.state = {
      error: null,
      open: false
    };
    this.login = this.login.bind(this);
    this.handleRequestClose = this.handleRequestClose.bind(this);
```

then you need to update render function as following:
```
<Snackbar
  autoHideDuration={4000}
  open={!!this.state.error}
  message={this.state.error || ""}
  onRequestClose={this.handleRequestClose} />
```

so after adding it, the render function will look like:
```
render () {
  return (
    <div>
        <h1>Login view</h1>
        <div style={{maxWidth: 450, margin: '0 auto'}}>
          <LoginForm
            onSubmit={this.login} />
        </div>
        <Snackbar
          autoHideDuration={4000}
          open={!!this.state.error}
          message={this.state.error || ""}
          onRequestClose={this.handleRequestClose} />
    </div>
  );
}
```

OK, so we are handling login's error - now let's work on successful logins.

#### Handling successful logins in the LoginView's component


For handling successful token's backend responses add to the login function under the:
```
    if(tokenRes === "INVALID") {
      // login failed, get error msg
      let errorRes = await falcorModel.getValue('login.error');
      this.setState({error: errorRes});
      return;
    }

```

a new code for handling correct responses as following:
```
if(tokenRes) {
  let username = await falcorModel.getValue('login.username');
  let role = await falcorModel.getValue('login.role');

  localStorage.setItem("token", tokenRes);
  localStorage.setItem("username", username);
  localStorage.setItem("role", role);

  this.props.history.pushState(null, '/dashboard');
  return;
} else {
  alert("Fatal login error, please contact an admin");
}

return; 
```

#### Explanation
After we know that the tokenRes is not "INVALID" and it's not an undefined (otherwise let's show a fatal error to the user) then we do certain steps:
1) We are fetching username from the Falcor's model (***await falcorModel.getValue('login.username')***)
2) We are fetching user's role (***await falcorModel.getValue('login.role')***)
3) then we save all the known variables from backend into our localStorage with:
```
  localStorage.setItem("token", tokenRes);
  localStorage.setItem("username", username);
  localStorage.setItem("role", role);
```

At the same end we are sending our user's to the /dashboard route with use of ***this.props.history.pushState(null, '/dashboard')***.



#### Few important notes about DashboardView and security

At this point we won't secure DashboardView as there aren't any important stuff to secure - we will do it later when we will put more assets/features into this route which at the end of our book will be an editor's dashboard that will give a control over all articles in the system.

The only remaining step for us is to make a RegistrationView component, this route also will be available for everyone at this point, later  in the book we will make a mechanism that only the main admin will be able to add new editors into the system (and manage them).

![dashboard v1](http://test.przeorski.pl/book/106_dashboard_v1.png)

#### Starting working on the new editor's registration

In order to wrap up the registration, let's first make some changes in our User's scheme from Mongoose's config file at location ***server/configMongoose.js***:
```
var userSchema = {
  "username" : String,
  "password" : String,
  "firstName" : String,
  "lastName" : String,
  "email" : String,
  "role" : String,
  "verified" : Boolean,
  "imageUrl" : String
}
```

to new scheme as following:
```
var userSchema = {
  "username" : { type: String, index: {unique: true, dropDups: true }},
  "password" : String,
  "firstName" : String,
  "lastName" : String,
  "email" : { type: String, index: {unique: true, dropDups: true }},
  "role" : { type: String, default: 'editor' },
  "verified" : Boolean,
  "imageUrl" : String
}
```

As you can see above, we have added unique's indexes to the "username" and the "email"'s fields. We also have added a default vlaue for a role, as the any next user in our collection will be an editor (not an admin).

#### Adding register's falcor-route

In the file located at ***server/routesSession.js*** you need to add a new route (next to the login's route):
```
  { 
    route: ['register'],
    call: (callPath, args) => 
      {
        let newUserObj = args[0];
        newUserObj.password = newUserObj.password+"pubApp";
        newUserObj.password = crypto.createHash('sha256').update(newUserObj.password).digest('hex');
        let newUser = new User(newUserObj);
        return newUser.save((err, data) => { if (err) return err; })
          .then ((newRes) => {
            /*
              got new obj data, now let's get count:
             */
            let newUserDetail = newRes.toObject();
            if(newUserDetail._id) {
              return null; // Mocked for now
            } else {
              // registration failed
              return [
                {
                  path: ['register', 'newUserId'], 
                  value: 'INVALID'
                },
                {
                  path: ['register', 'error'], 
                  value: 'Registration failed - no id has been created'
                }
              ];
            }
            return;
          }).catch((reason) => console.error(reason));
      }
  }
```

What the above's code is actually do is simply receiving the new user's object from the front-end via ***let newUserObj = args[0]***...

... then we are salting the password that we will store in our database:
```
        newUserObj.password = newUserObj.password+"pubApp";
        newUserObj.password = crypto.createHash('sha256').update(newUserObj.password).digest('hex');
```

and then we are creating a new User Model from Mongoose via ***let newUser = new User(newUserObj)***. Because the ***newUser*** variable is a new model (not saved yet) of User then we need to save it with this code:
```
return newUser.save((err, data) => { if (err) return err; })
```

... and after it's saved into the db and the promise has been resolved we are managing an invalid entry to db first making the Mongoose result's object into a simple JSON structure with ***let newUserDetail = newRes.toObject();***.

And after we are done with it, then we are returning an INVALID information to the Falcor's model:
```
  // registration failed
    return [
      {
        path: ['register', 'newUserId'], 
        value: 'INVALID'
      },
      {
        path: ['register', 'error'], 
        value: 'Registration failed - no id has been created'
      }
```

OK, so we are done with handling an invalid user registration from Falcor. 
Next step is to replace this:
```
// you shall already have this in your codebase, just a recall
if(newUserDetail._id) {
  return null; // Mocked for now
}
```

and the above needs to be replaced with:
```
if(newUserDetail._id) {
  let newUserId = newUserDetail._id.toString();
  return [
    {
      path: ['register', 'newUserId'], 
      value: newUserId
    },
    {
      path: ['register', 'error'], 
      value: false 
    }
  ];
}
```

#### Explanation:
We need to cast our new user's id into the String ***newUserId = newUserDetail._id.toString()*** (otherwise it will break the code).

As you can see, we have a standard return statement that complements the model in falcor.

To quickly recalling, after it will return correctly on backend (as above), then we will be able to request this value on front-end as following: ***let newUserId = await falcorModel.getValue(['register', 'newUserId']);*** (this is just example here how to fetch this newUserId on the client-side - don't write it into your code, we will do it in a minute below).

You will get used to after few more examples.

#### Front-end implementation (RegisterView and RegisterForm)

Let's create first a component that will manage on the front-end the register's form with following actions:
```
$ pwd 
$ [[[you shall be at the components folder]]]
$ touch RegisterForm.js
```

and the content of that file:
```
import React from 'react';
import Formsy from 'formsy-react';
import { RaisedButton, Paper } from 'material-ui';
import DefaultInput from './DefaultInput';

export class RegisterForm extends React.Component {
  constructor() {
    super();
  }

  render() {
    return (
      <Formsy.Form onSubmit={this.props.onSubmit}>
        <Paper zDepth={1} style={{padding: 32}}>
          <h3>Registration form</h3>
          <DefaultInput onChange={(event) => {}} name='username' title='Username' required />
          <DefaultInput onChange={(event) => {}} name='firstName' title='Firstname' required />
          <DefaultInput onChange={(event) => {}} name='lastName' title='Lastname' required />
          <DefaultInput onChange={(event) => {}} name='email' title='Email' required />
          <DefaultInput onChange={(event) => {}} type='password' name='password' title='Password' required />
          <div style={{marginTop: 24}}>
            <RaisedButton
              secondary={true}
              type="submit"
              style={{margin: '0 auto', display: 'block', width: 150}}
              label={'Register'} />
          </div>
        </Paper>
      </Formsy.Form>
    );
  }
}
```

The above's registration component is creating a form exactly the same way as on the LoginForm. After a user clicks the "Register"'s button then it sends a callback to the our ***src/views/RegisterView.js*** component (that we will create in a moment).

Just please remember that in the components' directory we keep only DUMB components so all the communication with rest of the app must to be done via callbacks like in this example.

#### RegisterView

Let's create a RegisterView's file:
```
$ pwd 
$ [[[you shall be at the views folder]]]
$ touch RegisterView.js
```

and it's content is:
```
"use strict";
import React from 'react';
import falcorModel from '../falcorModel.js';
import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';
import { Snackbar } from 'material-ui';
import { RegisterForm } from '../components/RegisterForm.js';

const mapStateToProps = (state) => ({ 
  ...state 
});

const mapDispatchToProps = (dispatch) => ({
});
```

That are standard things that we use in our SMART components (we need falcorModel in order to comunicate with backend and the mapStateToProps and the mapDispatchToProps in order to communicate with our Redux's store/reducer).

OK, it's not all of the register view, next let's add a component:
```
const mapDispatchToProps = (dispatch) => ({
});

class RegisterView extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: null
    };
    this.register = this.register.bind(this);
  }

  render () {
    return (
      <div>
          <h1>Register</h1>
          <div style={{maxWidth: 450, margin: '0 auto'}}>
            <RegisterForm 
              onSubmit={this.register} />
          </div>
      </div>
    );
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(RegisterView);
```

As you can find on the above code snippet, we are missing the ***register*** function, so between the ***constructor*** and the ***render*** function add also the function which is as following:
```
  async register (newUserModel) {
    console.info("newUserModel", newUserModel);

    let registerResult = await falcorModel
      .call(
            ['register'],
            [newUserModel]
          ).
      then((result) => {
        return result;
      });

    let newUserId = await falcorModel.getValue(['register', 'newUserId']);
    if(newUserId === "INVALID") {
      let errorRes = await falcorModel.getValue('register.error');
      this.setState({error: errorRes});
      return;
    }

    if(newUserId) {
      this.props.history.pushState(null, '/login');
      return;
    } else {
      alert("Fatal registration error, please contact an admin");
    }
  }
```
As you can find above, the ***async register (newUserModel)*** function is asynchronous and friendly to the awaits. Next we are just logging to the console what a user has submited with ***console.info("newUserModel", newUserModel);***. After that we are querying with a call the falcor-router:
```
    let registerResult = await falcorModel
      .call(
            ['register'],
            [newUserModel]
          ).
      then((result) => {
        return result;
      });
```
After we have called the router then we fetch the response with:
```
let newUserId = await falcorModel.getValue(['register', 'newUserId']);
```

... and depending on the response from the backend, then we do different things:
1) For INVALID we are fetching and setting error message into the component's state (***this.setState({error: errorRes})***).

2) If the user has registered correctly, then we have their new id and we are asking user to login with history's push state (***this.props.history.pushState(null, '/login');***).


At this point we shall be able to register with this form:

![registration form](http://test.przeorski.pl/book/107_registration_form.png)







